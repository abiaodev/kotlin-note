## Channel
但在某些业务场景下，我们往往需要协程返回多个结果，比如微信等软件的 IM 通道接收的消息，或者是手机 GPS 定位返回的经纬度坐标需要实时更新。

Channel 就是管道
```kotlin

// 代码段1

fun main() = runBlocking {
    // 1，创建管道
    val channel = Channel<Int>()

    launch {
        // 2，在一个单独的协程当中发送管道消息
        (1..3).forEach {
            channel.send(it) // 挂起函数
            logX("Send: $it")
        }
    }

    launch {
        // 3，在一个单独的协程当中接收管道消息
        for (i in channel) {  // 挂起函数
            logX("Receive: $i")
        }
    }

    logX("end")
}

/*
================================
end
Thread:main @coroutine#1
================================
================================
Receive: 1
Thread:main @coroutine#3
================================
================================
Send: 1
Thread:main @coroutine#2
================================
================================
Send: 2
Thread:main @coroutine#2
================================
================================
Receive: 2
Thread:main @coroutine#3
================================
================================
Receive: 3
Thread:main @coroutine#3
================================
================================
Send: 3
Thread:main @coroutine#2
================================
// 4，程序不会退出
*/
```
以上的程序运行之后程序并不会退出，整个程序还处于运行状态。要解决这个问题，我们需要再发送之后加上一行代码
```kotlin
channel.close()
```
Channel是一种**协程资源**，如果我们在使用之后不主动关闭的话，会造成不必要的资源浪费。

Channel的构造方法有三个参数
- capacity 代表了管道的容量
    ```
    RENDEZVOUS，默认值,也就代表了 Channel 的容量为 0。
    UNLIMITED，代表了无限容量。
    CONFLATED，代表了容量为 1，新的数据会替代旧的数据。
    BUFFERED，代表了具备一定的缓存容量，默认情况下是 64，具体容量由这个 VM 参数决定 "kotlinx.coroutines.channels.defaultBuffer"。
    ```
- onBufferOverflow  等管道的容量满了时，Channel 的应对策略是怎么样的
    ```
    SUSPEND，当管道的容量满了以后，如果发送方还要继续发送，我们就会挂起当前的 send() 方法。由于它是一个挂起函数，所以我们可以以非阻塞的方式，将发送方的执行流程挂起，等管道中有了空闲位置以后再恢复。
    DROP_OLDEST，顾名思义，就是丢弃最旧的那条数据，然后发送新的数据。DROP_LATEST，丢弃最新的那条数据。这里要注意，这个动作的含义是丢弃当前正准备发送的那条数据，而管道中的内容将维持不变。
    ```
- onUndeliveredElement 相当于一个异常处理回调。当管道中的某些数据没有被成功接收的时候，这个回调就会被调用。

### Channel 关闭引发的问题
除了使用构造函数创建Channel之外，Kotlin 官方其实还为我们提供了另一种创建 Channel 的方式，也就是 produce{} 高阶函数。
```kotlin

// 代码段9

fun main() = runBlocking {
    // 变化在这里
    val channel: ReceiveChannel<Int> = produce {
        (1..3).forEach {
            send(it)
            logX("Send: $it")
        }
    }

    launch {
        // 3，接收数据
        for (i in channel) {
            logX("Receive: $i")
        }
    }

    logX("end")
}
```
使用 produce{} 创建以后，就不用再去调用 close() 方法了，因为 produce{} 会自动帮我们去调用 close() 方法。

Channel 有两个属性：isClosedForReceive、isClosedForSend。

这两个属性，就可以用来判断当前的 Channel 是否已经被关闭。由于 Channel 分为发送方和接收方，所以这两个参数也是针对这两者的。也就是说，对于发送方，我们可以使用“isClosedForSend”来判断当前的 Channel 是否关闭；对于接收方来说，我们可以用“isClosedForReceive”来判断当前的 Channel 是否关闭。

最好不要用 channel.receive()。即使配合 isClosedForReceive 这个判断条件，我们直接调用 channel.receive() 仍然是一件非常危险的事情！

除了可以使用 for 循环以外，还可以使用 Kotlin 为我们提供的另一个高阶函数：channel.consumeEach {}。我们再来看一个例子：
```kotlin

// 代码段14

fun main() = runBlocking {
    val channel: ReceiveChannel<Int> = produce(capacity = 3) {
        (1..300).forEach {
            send(it)
            println("Send $it")
        }
    }

    // 变化在这里
    channel.consumeEach {
        println("Receive $it")
    }

    logX("end")
}

/*
输出结果：

正常
*/
```
所以，当我们想要读取 Channel 当中的数据时，我们一定要使用 for 循环，或者是 channel.consumeEach {}，千万不要直接调用 channel.receive()。

补充：在某些特殊场景下，如果我们必须要自己来调用 channel.receive()，那么可以考虑使用 receiveCatching()，它可以防止异常发生。

### 为什么说 Channel 是“热”的？
这种“不管有没有接收方，发送方都会工作”的模式，我们将其认定为“热”
```kotlin

// 代码段15

fun main() = runBlocking {
    // 只发送不接受
    val channel = produce<Int>(capacity = 10) {
        (1..3).forEach {
            send(it)
            println("Send $it")
        }
    }

    println("end")
}

/*
输出结果：
end
Send 1
Send 2
Send 3
程序结束
*/
```
当我们把 capacity 改成 0 以后，可以看到 Channel 的发送方仍然是会工作的，只是说，在它调用 send() 方法的时候，由于接收方还未就绪，且管道容量为 0，所以它会被挂起。所以，它仍然还是有在工作的。最直接的证据就是：这个程序将无法退出，一直运行下去。

----

## Flow：为什么说Flow是“冷”的？
简单的异步场景，我们可以直接使用挂起函数、launch、async；至于复杂的异步场景，我们就可以使用 Flow。在 Android 领域，Flow 甚至还要取代原本 LiveData 的地位。

Flow 和我们上节课学习的 Channel 不一样，Flow 并不是只有“发送”“接收”两个行为，它当中流淌的数据是可以在中途改变的

Flow 的数据发送方，我们称之为“上游”；数据接收方称之为“下游”。跟现实生活中一样，上下游其实也是相对的概念。
```kotlin

// 代码段1

fun main() = runBlocking {
    flow {                  // 上游，发源地
        emit(1)             // 挂起函数
        emit(2)
        emit(3)
        emit(4)
        emit(5)
    }.filter { it > 2 }     // 中转站1
        .map { it * 2 }     // 中转站2
        .take(2)            // 中转站3
        .collect{           // 下游
            println(it)
        }
}

/*
输出结果：                       
6
8
*/
```
- flow{}，是一个高阶函数，它的作用就是创建一个新的 Flow。在它的 Lambda 当中，我们可以使用 emit() 这个挂起函数往下游发送数据，这里的 emit 其实就是“发射”“发送”的意思。上游创建了一个“数据流”，同时也要负责发送数据。这跟现实生活也是一样的：长江里的水从上游产生，这是天经地义的。所以，对于上游而言，只需要创建 Flow，然后发送数据即可，其他的都交给中转站和下游。
- filter{}、map{}、take(2)，它们是中间操作符，就像中转站一样，它们的作用就是对数据进行处理，这很好理解。Flow 最大的优势，就是它的操作符跟集合操作符高度一致。只要你会用 List、Sequence，那你就可以快速上手 Flow 的操作符，这中间几乎没有额外的学习成本。
- collect{}，也被称为终止操作符或者末端操作符，它的作用其实只有一个：终止 Flow 数据流，并且接收这些数据。

除了使用 flow{} 创建 Flow 以外，我们还可以使用 flowOf() 这个函数。所以，从某种程度上讲，Flow 跟 Kotlin 的集合其实也是有一些相似之处的。
```kotlin

// 代码段2

fun main() = runBlocking {
    flowOf(1, 2, 3, 4, 5).filter { it > 2 }
        .map { it * 2 }
        .take(2)
        .collect {
            println(it)
        }

    listOf(1, 2, 3, 4, 5).filter { it > 2 }
        .map { it * 2 }
        .take(2)
        .forEach {
            println(it)
        }
}

/*
输出结果
6
8
6
8
*/
```

Flow的创建有三种方式
![](/img/flow%E5%88%9B%E5%BB%BA.webp)

### Flow中间操作符
#### 集合抄袭过来的
#### 生命周期相关
- onStart，它的作用是注册一个监听事件：当 flow 启动以后，它就会被回调。onStart 的执行顺序，并不是严格按照上下游来执行的。因为它本质上是一个回调。
- onCompletion 的执行顺序，跟它在 Flow 当中的位置无关。onCompletion 只会在 Flow 数据流执行完毕以后，才会回调。onCompletion{} 在面对以下三种情况时都会进行回调：
    ```
    情况 1，Flow 正常执行完毕；
    情况 2，Flow 当中出现异常；
    情况 3，Flow 被取消。
    ```
#### catch 异常处理
catch 这个操作符，其实就相当于我们平时使用的 try-catch 的意思。只是说，后者是用于普通的代码，而前者是用于 Flow 数据流的，两者的核心理念是一样的。不过，考虑到 Flow 具有上下游的特性，catch 这个操作符的作用是和它的位置强相关的。

catch 的作用域，仅限于 catch 的上游。换句话说，发生在 catch 上游的异常，才会被捕获，发生在 catch 下游的异常，则不会被捕获。

对于collect中发生的异常，最简单的办法，其实是使用 try-catch，把 collect{} 当中可能出现问题的代码包裹起来。
```kotlin

// 代码段10

fun main() = runBlocking {
    flowOf(4, 5, 6)
        .onCompletion { println("onCompletion second: $it") }
        .collect {
            try {
                println("collect: $it")
                throw IllegalStateException()
            } catch (e: Exception) {
                println("Catch $e")
            }
        }
}
```
#### 切换 Context：flowOn、launchIn
Flow 非常适合复杂的异步任务。在大部分的异步任务当中，我们都需要频繁切换工作的线程。对于耗时任务，我们需要线程池当中执行，对于 UI 任务，我们需要在主线程执行。

而在 Flow 当中，我们借助 flowOn 这一个操作符，就可以灵活实现以上的需求。

flowOn 操作符也是和它的位置强相关的。它的作用域跟前面的 catch 类似：flowOn 仅限于它的上游。

如果想要指定 collect 当中的 Context，该怎么办呢？我们能想到的最简单的办法，就是用前面学过的：withContext{}。
```kotlin

// 代码段13

// 不推荐
flow.flowOn(Dispatchers.IO)
    .filter {
        logX("Filter: $it")
        it > 2
    }
    .collect {
        withContext(mySingleDispatcher) {
            logX("Collect $it")
        }
    }
/*
输出结果：
collect{}将运行在MySingleThread
filter{}运行在main
flow{}运行在DefaultDispatcher
*/
```

